\appendix
\chapter{Implementación del código de la simulación \label{app:Implementación}}
%\section{Implementación del código de la simulación}
\noindent La implementación de los códigos que ejecutan la simulación Monte Carlo se realizó con los lenguajes C y Python. Con C se realiza todo el trabajo de alto costo computacional, mientras que Python cumple un rol de interfaz de entrada para los parámetros de la simulación, de procesamiento de los datos obtenidos de ella y de visualización de resultados por medio de gráficos.

A grandes rasgos, en el código en C están implementadas las funciones que hacen los cálculos antes mencionados: el cálculo de la probabilidad de ionización $P_{eh}$ a partir de la expresión \eqref{ec:ProbabilidadIonizacion}, el cálculo del parámetro $\alpha = \alpha(E_{R})$ para la distribución Beta, a partir de la cual se genera una realización de la variable aleatoria de la que se puede despejar la energía transferida a un par electrón-hueco por ionización. Finalmente, por recursión, se simulan los procesos de ionización en cascada y se cuenta la cantidad final de electrones ionizados.

La parte escrita en Python se encarga de ejecutar el programa en C las veces que sean necesarias y con los parámetros iniciales de interés para obtener el resultado buscado.

Más en detalle, el programa en C consta de un total de $6$ funciones, las cuales se listan a continuación con una breve descripción de su funcionamiento
\begin{enumerate}[label=\arabic*., listparindent=1.5em]
    \item \verb|Random()|: Esta función genera realizaciones \verb|p_rand| de una variable aleatoria de distribución uniforme, entre $0$ y $1$. Se usa para generar una probabilidad de comparación en el Monte Carlo.
    \item \verb|Peh(E_r, A)|: Esta se encarga de realizar el cómputo de la probabilidad de ionización, según la ecuación \eqref{ec:ProbabilidadIonizacion}, a partir de la energía $E_{R}$, que es un argumento inicial en el programa y es ingresado desde Python. Esta probabilidad, \verb|p_eh|, se compara con \verb|p_rand| en el algoritmo de aceptación del Monte Carlo.
    \item \verb|alpha(E_r)|: Calcula el valor del parámetro $\alpha$ en base al valor del parámetro \verb|E_r|. Si bien el parámetro \verb|E_r| es un parámetro inicial que, por ejemplo, para el flúor es $677\,\si{eV}$, a medida que evoluciona el sistema, la energía se va consumiendo en ionizacionar y este parámetro cambia. Con cada actualización se calcula nuevamente el valor de $\alpha$ para la distribución Beta. El valor del parámetro se calcula entonces como
    \begin{equation*}
        \alpha =
        \left\{ \begin{array}{lcc}
             0.1 & \mbox{si} & E_{r} < E_{g}\\
             1 & \mbox{si} & E_{g} < E_{r} < 4.2\,\si{eV}\\
             0.02E_{r} + 0.95 & & \mbox{en otro caso.}
             \end{array}
        \right.
    \end{equation*}
    \item \verb|evolucionar(E_r, A, rand_beta)|: Genera la evolución del sistema mediante el algoritmo de aceptación del Monte Carlo, haciendo uso de las funciones anteriores. Implementa un bucle \verb|while|, cuya condición es que se repita el proceso mientras que la energía \verb|E_r| sea mayor que la energía del gap del silicio \verb|E_g|. Dentro del bucle se calcula la probabilidad \verb|p_eh| de ionización, el parámetro $\alpha$, que luego es usado para generar un número pseudo aleatorio con distribución Beta del cual despejar la fracción de energía transferida (\verb|E_traf|) a un par electrón hueco al ionizar y, por último, genera el número pseudo aleatorio de distribución uniforme con cual comparar la probabilidad de ionización en el Monte Carlo para ver si el se acepta el nuevo estado.\\
    \indent Una vez que se tienen estos valores, siempre y cuando se cumpla que la probabilidad de ionizacion \verb|p_eh| sea mayor que \verb|p_rand| y que al mismo tiempo la fracción de energía \verb|E_tranf| sea mayor que $3.75\,\si{eV}$ (valor medio para la energía de creación electrón hueco $\varepsilon_{\eh}$), entonces se actualiza el valor de la energía inicial \verb|E_r| restándole la fracción de energía transferida. Además, también, se guardan en una lista las energías transferidas \verb|E_r|. Notar que la cantidad de elementos de la lista será la cantidad de pares electrón-hueco generados por una rama de la cascada con energía inicial \verb|E_r|. Luego, cada elemento de la lista se transforma, para otra rama, en \verb|E_r|, generando una nueva lista. Repitiendo con todas las energías de toda la lista y todas las sublistas, se pueden contar los electrones ionizados.\\
    \indent De no cumplirse la condición del Monte Carlo, el sistema pierde energía por emisión de fonones, es decir, la energía \verb|E_r| se actualiza restándole un valor fijo de energía $\hbar \omega = 0.063\,\si{eV}$. El resultado de esta función es una lista con las energías de una sola rama de la cascada.
    \item \verb|recursion(E_r, A, rand_beta)|: Esta función cuenta de manera recursiva la cantidad de electrones ionizados durante la cascada. La recursion, en este caso, tiene la ventaja de que es muy sencilla de implementar, pero tiene como desventaja que no es tan sencillo entender por qué funciona correctamente. Es por esto que fue necesario crear un conjunto de datos de prueba para contrastar que los resultados que arroja la función son los esperados.\\
    \indent Lo primero que hace esta función es generar una lista energías, \verb|Energia|, llamando a la función \verb|evolucionar()| y luego se itera sobre todas estas, contando la cantidad total de elementos que posee. Esas energías son las que fueron usadas para ionizar un par electrón hueco, así que la cantidad de energías que alberga la lista es equivalente a la cantidad de pares generados. Notar que a \verb|recursion()| se le pasa como argumento \verb|E_r|. Esto significa que cuando dentro de \verb|recursion()| se vuelva a llamar a ella misma, pero ahora en vez de usar como argumento \verb|E_r|, se usa el primer elemento de la lista \verb|Energia|, es decir \verb|Energia[0]|, se produce una nueva lista a partir de una energía inicial menor. A esta nueva lista se le cuenta la cantidad de elementos y ese será el número de nuevas ionizaciones. Luego se repite para el elemento \verb|Energia[1]|, se genera otra lista de energías, lo mismo para \verb|Energia[2]|, etc. El proceso se repite hasta que todas las energías de la lista original se agotaron. Luego, las sublistas generadas repiten el proceso para todos sus elementos hasta que eventualmente la energía de las listas no es suficiente para seguir ionizando y el proceso termina.\\
    \indent El valor de salida de la función \verb|recursion()| es un entero y contabiliza la cantidad de elementos encontrados en la lista, es decir, la cantidad de ionizaciones. Durante el proceso de recursión se van sumando todas las cantidades de carga ionizada en cada paso y finalmente se obtiene la carga total generada durante la cascada.
    \item \verb|main()|: Esta se encarga de llevar adelante las repeticiones del experimento con el fin de obtener estadística. Además, en esta se definen los parámetros necesarios para la simulación, como ser la energía inicial \verb|E_r|, el parámetro \verb|A|, la cantidad de experimentos que se quieren realizar (\verb|trials|) y la generación de un archivo \verb|.txt| con los datos obtenidos para ser importados posteriormente con Python.
\end{enumerate}
Cabe destacar que de esta simulación el único resultado que se obtiene es la distribución de carga para una dada energía inicial $E_{r}$. Es decir, no puede conocerse ningún proceso intermedio o la \textit{historia} del proceso, solo la cantidad total de electrones generados.