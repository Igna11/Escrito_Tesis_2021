\chapter*{Apéndice:}
\section*{Implementación del código de la simulación}
\noindent La implementación de los códigos que ejecutan la simulación Montecarlo se realizó con los lenguajes C y Python. Con C se realiza todo el trabajo de alto costo computacional, mientras que Python cumple un rol de interfaz para los parámetros de la simulación, como ser, por ejemplo, la energía inicial, la cantidad de corridas del Montecarlo, etc.\\
\indent A grandes rasgos, en el código en C están implementadas las funciones que hacen los cálculos antes mencionados: El cálculo de la probabilidad de ionización $P_{eh}$ a partir de la expresión \eqref{ec:ProbabilidadIonizacion}, el cálculo del parámetro $\alpha = \alpha(E_{R})$ según la energía $E_{R}$ para la distribución Beta, a partir de la cual se genera una realización de la variable aleatoria de la que se puede despejar la energía transferida a un par electrón-hueco por ionización. Finalmente, por recursión se simulan los procesos de ionización en cascada y se cuenta la cantidad final de electrones ionizados.\\
\indent Por otro lado, la función del código en Python no es más ejecutar el programa en C las veces que sean necesarias y con los parámetros iniciales de interés para obtener el resultado buscado.\\
\indent Más en detalle, el programa en C consta de un total de $6$ funciones, las cuales se listan a continuación con una breve descripción de su funcionamiento
\begin{enumerate}[label=\arabic*., listparindent=1.5em]
    \item \verb|Random()|: Es simplemente una función que genera realizaciones \verb|p_rand| de una distribución uniforme, entre $0$ y $1$. Se usa para generar una probabilidad de comparación en el Montecarlo.
    \item \verb|Peh(E_r, A)|: Es la función encargada de realizar el cómputo de la probabilidad de ionización, según la ecuación \eqref{ec:ProbabilidadIonizacion}, a partir de la energía $E_{R}$, que es un parámetro inicial que es ingresado con Python. Esta probabilidad \verb|p_eh| se compara con \verb|p_rand| en el algoritmo de aceptación del Montecarlo.
    \item \verb|alpha(E_r)|: Calcula el valor del parámetro $\alpha$ en base al valor del parámetro \verb|E_r|. Si bien el parámetro \verb|E_r| es un parámetro inicial, que para el Flúor es $677\,\si{eV}$, a medida que evoluciona el sistema, la energía se va perdiendo en ionizaciones y este parámetro es actualizado. Con cada actualización se calcula nuevamente el valor de $\alpha$ de para la distribución Beta. El valor del parámetro se calcula entonces como
    \begin{equation*}
        \alpha =
        \left\{
            \begin{matrix}
                0.1\ \mbox{si}\ E_{r} < E_{g}\\
                1\ \mbox{si}\ E_{g} < E_{r} < 2E_{g}\\
                1\ \mbox{si}\ 3.4\,\si{eV} < E_{r} < 4.2\,\si{eV}\\
                0.0207E_{r} + 0.95435\ \mbox{en otro caso.}
            \end{matrix}
        \right.
    \end{equation*}
    \item \verb|evolucionar(E_r, A, E_loss, rand_beta)|: Genera la evolución del sistema mediante Montecarlo, haciendo uso de las funciones anteriores. Implementa un bucle \verb|while|, cuya condición es que se repita el proceso mientras que la energía \verb|E_r| sea mayor que la energía del gap del Silicio \verb|E_g|. Dentro del bucle se calcula la probabilidad \verb|p_eh| de ionización, el parámetro $\alpha$, que luego es usado para generar un número pseudo aleatorio con distribución Beta del cual despejar la fracción de energía \verb|E_traf| que va a un par electrón hueco al ionizar y, por último, genera el número pseudo aleatorio de distribución uniforme con cual comparar la probabilidad de ionización en el Montecarlo.\\
    \indent Una vez que se tienen estos valores, siempre y cuando se cumpla que la probabilidad de ionizacion \verb|p_eh| sea mayor que \verb|p_rand| y que al mismo tiempo la fracción de energía \verb|E_tranf| sea mayor que $3.75\,\si{eV}$\footnote{Condición que cobra gran relevancia en los resultados y se explica en más datella en la siguiente sección} (valor medio para la energía de creación electrón hueco $\varepsilon_{\eh}$), entonces se actualiza el valor de la energía inicial \verb|E_r| restándole la fracción de energía transferida. Además, también, se guardan en una lista la resta entre las energías transferidas \verb|E_r| y la energía perdida por ionización \verb|E_loss|. Esta última es un parámetro configurable de la simulación, en la cual se puede considerar el caso donde la energía se conserva y \verb|E_loss = 0| o el caso en el que no hay conservación de energía y \verb|E_loss|$\neq$\verb|0|. Notar que la cantidad de elementos de la lista será la cantidad de pares electrón-hueco generados por una rama de la cascada con energía inicial \verb|E_r|. Luego, cada elemento de la lista se transforma, para otra rama, en \verb|E_r|, generando una nueva lista. Repitiendo con todas las energías de toda la lista y todas las sublistas, se pueden contar los electrones ionizados.\\
    \indent De no cumplirse la condición del Montecarlo, el sistema pierde energía por emisión de fonones, es decir, la energía \verb|E_r| se actualiza restándole un valor fijo de energía $\hbar \omega = 0.063\,\si{eV}$. El resultado de esta función es una lista con las energías de una sola rama de la cascada.
    \item \verb|recursion(E_r, A, E_loss, rand_beta)|: Esta función cuenta de manera recursiva la cantidad de electrones ionizados durante la cascada. La recursion, en este caso, tiene la ventaja de que es muy sencilla de implementar, pero tiene como desventaja que no es tan sencillo entender por qué funciona correctamente.\\
    \indent Lo primero que hace esta función es generar una lista energías, \verb|Energia|, llamando a la función \verb|evolucionar()| y luego se itera sobre todas estas, contando la cantidad total de elementos que posee. Esas energías son las que fueron usadas para ionizar un par electrón hueco, así que la cantidad de energías que alberga la lista es equivalente a la cantidad de pares generados. Notar que a \verb|recursion()| se le pasa como argumento \verb|E_r|. De modo que si dentro de \verb|recursion()| se vuelve a llamar a ella misma, pero ahora en vez de usar como argumento \verb|E_r|, se usa el primer elemento de la lista \verb|Energia|, es decir \verb|Energia[0]|, se produce una nueva lista a partir de una energía inicial menor y contando la cantidad de elementos. Si ahora se repite para el elemento \verb|Energia[1]|, se genera otra lista de energías. El proceso se repite hasta que todas las energías de la lista original se agotaron. Luego, las sublistas generadas repiten el proceso para todos sus elementos hasta que eventualmente la energía de las listas no es suficiente para seguir ionizando y el proceso termina.\\
    \indent El valor de salida de la función \verb|recursion()| es un entero y contabiliza la cantidad de elementos encontrados en la lista, es decir, la cantidad de electrones ionizados. Durante el proceso de recursión se van sumando todas las cantidades de carga ionizada en cada paso y finalmente se obtiene la carga total generada durante la cascada.
    \item \verb|main()|: Esta se encarga de llevar adelante las repeticiones del experimento con el fin de obtener estadística. Además, en esta se definen los parámetros necesario para la simulación, como ser la energía inicial \verb|E_r|, el parámetro \verb|A|, el valor de la energía que se pierde por ionizar \verb|E_loss|, la cantidad de experimentos que se quieren realizar \verb|trials| y la generación de un archivo \verb|.txt| con los datos obtenidos para ser levantados posteriormente con Python.
\end{enumerate}
Cabe destacar que de esta simulación el único resultado que se obtiene es la distribución de carga para una dada energía inicial $E_{r}$. Es decir, no puede conocerse ningún proceso intermedio o la \textit{historia} del proceso, solo la cantidad total de electrones generados.